# HTTP
HTTP(HyperText Transfer Protocol)는 웹 브라우저와 웹 서버가 데이터를 주고받기 위한 애플리케이션 계층 통신 프로토콜입니다.

## HTTP/1.1과 HTTP/2의 차이점
HTTP/1.1의 요청-응답 쌍은 동기적으로 수행되어야하기 때문에 앞선 요청이 처리되지 않는 경우, 그 뒤에 있는 요청들이 모두 차단됩니다. 즉, 이전의 요청에 대한 처리가 오랫동안 지연되면, 그 다음 요청도 그 만큼 지연되게 되고, 성능 저하 현상이 발생하는데, 이를 `HOL(Head of Line) Blocking` 이라고 합니다.

HTTP/1.1에서는 이를 개선하기 위해 동시 요청을 수행하려는 경우 `다중 TCP 연결`을 사용해야합니다.

하지만 TCP를 새롭게 연결/해제하는 작업은 `3-way handshaking`과 `4-way handshaking` 과정이 수행되어야하기 때문에 오버헤드가 발생합니다.

또한 HTTP/1.1은 요청마다 헤더를 전부 보내기 때문에 `헤더 중복`이 많아서 낭비가 발생합니다.

그리고 기본적으로 하나의 요청당 하나의 커넥션이 필요합니다. 이 때, `Connection: keep-alive` 라는 헤더를 포함시키면 커넥션을 재사용할 수 있습니다.(매 요청마다 새로운 TCP 커넥션을 생성하지 않아도 된다.)
> 하나의 TCP 커넥션을 재사용하는 것 뿐이므로, 요청은 병렬적이 아닌, 순차적으로 처리됩니다.
> 
> 이 떄, 커넥션 하나로도 요청/응답을 동시(병렬적)으로 처리 가능한 것을 `멀티플렉싱`이라고 합니다.

HTTP/1.1의 주요 특징을 다시 한 번 보자면 아래와 같습니다.
- request-response 구조
- 1개의 요청 당 1개의 TCP 커넥션
  - `Connection: keep-alive` 헤더를 포함하여 커넥션을 재사용할 수 있다.
- 요청한 순서대로 응답해야한다.(앞 요청이 지연되면 뒷 요청이 지연된다: HOL)
- 요청마다 헤더를 전부 보내기 때문에 '헤더 중복'이 발생한다.
- 멀티플렉싱이 불가하다.

위에서 언급된 HTTP/1.1의 단점을 보안하고 성능을 개선하기 위해 개발된 프로토콜이 `HTTP/2`입니다.
`HTTP/2`는 `멀티플렉싱, 헤더 압축, 이진 프레이밍, 리소스 우선순위 지정` 등의 특징이 있습니다.

### 멀티플렉싱
하나의 TCP 커넥션에서 여러 요청/응답을 주고 받을 수 있어, HOL 문제를 완화합니다.

### 헤더 압축
HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송됩니다. 이를 개선하기 위해 HTTP/2에서는 헤더를 압축하여 전송합니다.

또한, HTTP/1.1에서는 연속적으로 요청되는 HTTP 메시지들에게서 헤더값이 중복되는 부분이 많아 메모리가 낭비되었는데, HTTP/2에서는 헤더의 중복 필드를 재전송하지 않도록하여 데이터를 절약합니다.

### 이진 프레이밍(Binary Framing)
HTTP/1.1에서 언급되지 않았던 내용이 하나가 있습니다. 바로 HTTP/1.1에서의 메시지는 `Text`로 전송된다는 점인데요.
이와는 달리 HTTP/2는 `binary frame`으로 인코딩되어 전송됩니다.
> 이는 text로 보내는 방식은 Body는 압축이 되지만, 헤더는 압축이 되지 않고, 중복값이 있다는 문제 때문에 도입되었다고 합니다.

또한, HTTP/1.1에서는 헤더와 바디를 `\r`, `\n`과 같은 개행문자로 구분하지만, HTTP/2부터는 헤더와 바디가 `layer`로 구분됩니다.
![http2_header_body.png](images%2Fhttp2_header_body.png)

### 리소스 우선순위 지정
멀티플렉싱할 수 있게 되면서 요청과 응답이 동시에 이루어짐에 따라, 패킷 순서가 뒤섞이게 됩니다.
HTTP/2는 스트림들의 우선순위를 지정하게 함으로써 해결하였습니다.

통신 과정은 아래와 같습니다.
- 클라이언트는 서버에게 스트림을 보낼 때, 각 요청 자원에 가중치 우선순위를 지정하고 보냅니다.
- 요청을 받은 서버는 우선순위가 높은 응답이 클라이언트에 우선적으로 전달될 수 있도록 대역폭을 설정합니다.
- 응답 받은 각 프레임에는 어떤 스트림인지에 대한 고유 식별자가 있어서, 클라이언트는 조립할 수 있습니다.

## HTTP/2의 문제점
### 여전한 왕복시간: RTT(Round Trip Time)
아무리 개선되었다고 해도, HTTP/1.1이나 2는 여전히 TCP를 이용하기 때문에 handshake의 RTT로 인한 지연이 발생합니다.

### TCP 자체의 HOL(Head of Line) Blocking
위에서 멀티플렉싱을 통해 HOL 문제를 해결했다고 했습니다.

하지만 이는 애플리케이션 계층(L4)에서의 HOL을 해결한 것이지, 전송 계층(L3)에서의 TCP HOL을 해결한 것은 아닙니다.

기본적으로 TCP는 패킷이 유실되거나 오류가 있을 때 재전송하는데, 재전송 과정에서 앞 패킷의 지연이 발생하면 결국 HOL이 발생하기 때문입니다.

### 커넥션을 오래 유지함으로 인한 개인저보 누출 우려
HTTP/2는 기본적으로 성능을 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고 있습니다. 이는 개인 정보 유출에 악용될 우려가 있습니다.
> HTTP/1.1의 Keep-alive도 가지고 있는 문제라고 합니다.





