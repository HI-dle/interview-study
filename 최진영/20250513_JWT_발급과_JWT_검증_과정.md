이번에 MSA 팀프로젝트를 진행하면서 API Gateway, 회원/인증, 모니터링 구축 파트를 맡게 되었다. 이 포스트는 회원/인증을 구현하면서 JWT를 어떻게 발급하고 관리할 것인지에 초점을 두어 작성하고자 한다.

## 1. 회원 로그인 시 JWT 발급.. Body, Header, Cookie?
첫번째 고민은 회원이 로그인 한 후 JWT를 응답할 때, `바디, 헤더, 쿠키` 중에 어디로 응답해줄 것 인가? 에 대한 고민이었다.

토큰은 보안 상 탈취 위험을 최대한 줄여야하기 때문이었다.

답은 간단했다. 바디와 헤더보다는 쿠키가 보안적으로는 안전하기 때문이었다.(`secure, HttpOnly, SameSite` 등의 설정을 해줄 수 있으므로)

다만 쿠키로 발급하면, 또 다른 고민거리가 생긴다. 고민거리는 다음과 같았다.
- `Authorization` 규약을 지킬 수 없게 된다.
- 쿠키 속성 설정은 어떻게 해주어야 최대한 안전할 수 있을까?
- 클라이언트가 웹브라우저가 아닌 모바일앱이라면, 쿠키 스토리지가 존재하지 않는다.

### Authorization 규약
클라이언트에서 보통 토큰을 `Authorization` 헤더에 담아서 보내주는 것이 규약이다. 하지만, 서버에서 JWT를 발급할 때 쿠키로써 발급하고 `HttpOnly=true` 설정을 주게 되면, 클라이언트에서 JavaScript로 쿠키에 접근할 수 없게 되기 때문에 `Authozization` 헤더에 토큰을 담을 수 없게 된다.

하지만 `규약`이란 말은 관점을 달리해보면 해커 입장에서는 고민거리가 줄어든다고도 생각이 들었다.

또한, 어차피 우리 백엔드는 우리 프론트앤드와만 약속을 하면 되기 때문에 굳이 `Authorization` 규약을 따라야할까? 라는 의문이 들기도 했다.

따라서 이런 규약은 포기하고 쿠키의 보안을 가져가기로 결정했다.


### 그렇다면 쿠키 속성은 어떻게 설정해줄 것인가?
우리 애플리케이션 같은 경우 `액세스 토큰, 리프래시 토큰` 두 토큰이 발급된다.
각 토큰의 특성에 맞게 쿠키를 설정해줄 필요가 있었다.
결론부터 얘기하면 아래와 같다.
- 액세스 토큰: `HttpOnly=true`, `secure=true`, `SameSite=Lax`, `path="/"`
- 리프래시 토큰: `HttpOnly=true`, `secure=true`, `SameSite=Strict`, `path="/"`

공통으로 적용된 `HttpOnly=true`, `secure=true`는 자바스크립트의 접근을 방지하고, HTTPS 통신에서만 쿠키가 전송되도록 하기 위함이다.

사실 리프래시 토큰의 `path` 속성의 경우 `/refresh`라고 설정을 해줌으로써, 리프래시 요청에만 쿠키가 전송되도록 하는 것도 고민해봤으나, `/logout` 시에도 리프래시 토큰이 필요했고, `path`에 우리 앤드포인트가 노출되는 느낌도 들어서 `"/"`로 설정했다.

마지막으로 `SameSite`같은 경우는 액세스 토큰과 리프래시 토큰이 각각 `Lax와 Strict`로 설정되어 있는데, 외부 사이트에서 우리 사이트의 링크로 접근할 때 해당 쿠키를 요청에 포함할꺼냐로 생각했을 때, 액세스 토큰 쿠키의 경우는 요청에 포함되어야했고, 리프래시 토큰의 경우는 외부 사이트에서 `/refresh`나 `/logout` 과 같은 링크를 포함해선 안되기도 하고, 그럴 이유도 없기 때문에 `Strict`로 더 제약을 두었다.

### 클라이언트가 모바일이라면 쿠키 스토리지가 없는데?
단순히 생각해봤지만, 클라이언트가 모바일이라면 직접 앱스토리지에 저장해서 헤더로 넘겨주는 방식으로 진행해야할 것 같다는 생각을 했다.

## 2. 서버에서 토큰을 어떻게 관리할 것인가?
이 부분이 참 많은 고민이었다. 보안이 얽혀있어서 그런지 고민이 끝도 없었다.
가장 주된 고민은 **'토큰을 발급 시에 서버에서 화이트 리스트로 관리할 것인가?'** 였다.

- 화이트리스트로 토큰을 관리한다면 두 토큰 모두 관리할 것인가?

위에 저 고민이 돌아보니 가장 핵심이었던 것 같다.

일단 토큰을 서버에서 관리하면, `JWT secret key`가 탈취 되었을 때를 가정해도, 화이트리스트에 존재하지 않는 토큰이면 해당 토큰을 무효화할 수 있다. 또한 토큰 탈취를 감지 했을 때, 토큰을 무효화 할 수 있게 된다.

여기서 고민이 생겼는데, 리프래시 토큰만 서버에서 관리할 것인지, 두 토큰 모두 서버에서 관리할 것인지에 대한 고민이었다.

두 토큰 모두 관리한다면 보안 상 더 이점이 있겠지만, 리프래시 토큰만 관리한다면 토큰 스토리지의 부하가 두 토큰을 관리하는 것 보다는 적은 것이 이점이다.

이 두 가지는 서로 트레이드 오프라고 생각 됐고, 두 토큰 모두 서버에서 관리하는 방법은 세션 방식과 크게 다른 점이 없다고 느껴져서 결국은 리프래시 토큰만 서버에서 관리하기로 결정했다. 
보안적으로 생기는 공백은 액세스 토큰을 더 짧게 가져가고, 회원의 이상 행동을 감지하는 로직을 강화하는 것으로 채우면 될 것 같다.
> 애초에 토큰이 탈취 당했다면, 토큰만 탈취 당하지 않았을 것이라는 생각도 포함되었다.

## 3. JWT에 Role을 포함할 것인가?
JWT에 Role을 포함하여 발급하게 되면, 회원의 Role이 변경되었을 때 회원에게 "재로그인을 해주세요" 와 같은 문구를 띄우거나 하는 방향으로 진행되어야한다. 하지만 이 자체가 회원이 우리 서비스에 머무는 동안 불편할 것이라 판단됐다.

따라서 JWT에 Role을 포함하지 않기로 결정했고, 이에 따라 우리 프로젝트의 JWT 검증 플로우에 변화가 생겼다.

일단 우리 프로젝트는 MSA이다. 각 마이크로 서비스에서 회원의 정보를 사용하기 위해 게이트웨이에서 요청으로 넘어온 JWT를 파싱하고 Passport 객체를 만들어서 헤더로 넘겨주게 된다.

하지만 JWT에는 Role이 포함하지 않기로 결정했기 때문에 매 요청마다 JWT에서 `회원id`를 도출해내어 회원의 `Role`을 DB에서 조회해야만 했다.

대규모 트래픽인 상황에서 게이트웨이의 `SPOF`를 고려하게 되는데, 게이트웨이로 들어오는 모든 요청이 1:1로 회원 서버에도 들어가기 때문에, 회원 서버의 `SPOF`를 대처해야하는 상황이 올 수도 있다.

하지만 `Role`과 같은 가변 정보를 JWT에 포함하지 않는 것이 더 맞다고 판단했다. 또한 `Role`과 같은 정보는 자주 바뀌지 않는 데이터이므로 Redis에 캐싱하여 해결할 수 있다고 판단했다.