# Garbage Collection(가비지 컬렉션)
## 가비지 컬렉션이란?
프로그램을 개발하다 보면 '유효하지 않은 메모리'인 `가비지(Garbage)`가 발생하게 됩니다. C언어를 이용하면 `free()` 라는 함수를 통해 직접 메모리를 해제해주어야 합니다.

하지만, Java나 Kotlin을 이용해 개발을 하다 보면 개발자가 메모리를 직접 해제해주는 일이 없습니다. 그 이유는 바로 JVM의 '가비지 컬렉터'가 `불필요한 메모리를 알아서 정리`해주기 때문입니다.

따라서, 개발자는 메모리 관리에 대해 걱정하지 않고 코드 작성에 집중할 수 있게 됩니다.
> 자바도 `System.gc()`를 이용해 호출할 수 있지만, 해당 메서드를 호출하는 것은 시스템의 성능에 매우 큰 영향을 미치므로 절대 호출해서는 안된다고 합니다.

## 가비지 컬렉션의 대상
가비지 컬렉션은 어떤 Object를 가비지로 판단할까요?

가비지 컬렉션은 특정 객체가 가비지인지 판단하기 위해서 도달성, 도달 능력(Reachability)이라는 개념을 적용합니다.

객체에 참조(래퍼런스)가 있다면 `Reachable`로 구분되고, 객체에 유효한 래퍼런스가 없다면 `Unreachable`로 구분해버리고 수거해버립니다.
- `Reachable`: 객체가 참조되고 있는 상태
- `Unreachable`: 객체가 참조되고 있지 않은 상태(`GC`의 대상이 됨)

![jvm_memory.png](images%2Fjvm_memory.png)

예를 들어, JVM 메모리에서 객체들은 실질적으로 `Heap 영역`에 생성되고, `Method Area`나 `Stack Area`에서는 힙 영역에 생성된 객체의 주소만 참조하는 형식으로 구성됩니다.

이 때, 힙 영역의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인해 힙 영역 객체를 참조하는 변수가 삭제되는 현상이 발생하면, 위의 그림에서의 빨간색 박스(2번)과 같이 `Unreachable`이 발생하게 됩니다.
이러한 객체를 주기적으로 가비지 컬렉터가 제거해줍니다.
> '더 이상 어떤 경로에서도 참조되지 않는 객체가 GC의 대상입니다.' 
> 
> 다른 말로는, 'Root에서부터 더 이상 참조 체인을 타고 도달할 수 없는 객체가 GC의 대상이다.' 라고 하는데요.
> 
> Root는 [스택 변수, static 변수, JNI, 현재 살아있는 스레드가 참조하는 객체]들이 포함됩니다.

---
## 가비지 컬렉션 동작 방식
가비지 컬렉션 과정에는 [마킹, 스윕, 압축] 등의 여러 단계가 포함됩니다.
### 마킹(Mark)
`마킹`은 가비지 컬렉션의 첫번째 단계로, 여전히 프로그램에서 참조되고 있는 모든 객체를 표시하는 것입니다.

위에서 잠깐 설명했듯이, Root에서 도달할 수 없는 객체는 가비지 컬렉션의 대상이 됩니다.

### 스윕(Sweep)
참조하고 있지 않는 객체. 즉, `Unreachagble` 객체들을 힙에서 제거합니다.

### 압축(Compact)
일부 가비지 컬렉터는 스윕에 이어 압축 단계가 뒤따릅니다.
압축의 목적은 스윕을 하면서 발생한 '단편화'에 의해 "크고 연속된 빈 공간이 없어서 새로운 객체를 위한 메모리를 할당할 수 없는" 상황을 해결하기 위함입니다.
```java
// 초기:
[객체A][객체B][객체C][객체D][객체E][객체F]

// 시간이 지나고 GC 발생 후:
[객체A][    ][객체C][    ][    ][객체F] // '구멍'이 생긴다. 연속된 공간이 부족하면, 메모리 할당이 어려울 수 있다.

// Compacting 후:
[객체A][객체C][객체F][    ][    ][    ] // 살아있는 객체들을 앞쪽으로 땡긴다.
```

---
## 가비지 컬렉션의 2가지 알고리즘
- Full or Major 가비지 컬렉션
- Incremental or Minor 가비지 컬렉션

JVM의 힙 영역은 동적으로 래퍼런스 데이터가 저장되는 공간으로서, `가비지 컬렉션`의 대상이 되는 공간입니다.

힙 영역은 처음 설계될 때, 다음의 2가지를 전제(`Weak Generational Hypothesis`)로 설계되었습니다.

### Weak Generational Hypothesis(약한 세대 가설)
- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
- 오래된 객체(Old)에서 젊은 객체(Young)로의 참조는 아주 적제 존재한다.

이러한 특성을 이용해 JVM 개발자들은 보다 효율적인 메모리 관리를 위해 `객체의 생존 기간`에 따라 힙 영억을 물리적으로 나누게 되었고, `Young 영역과 Old 영역`으로 설계하였습니다.
![young_old.png](images%2Fyoung_old.png)

### Young 영역
young 영역은 새롭게 생성된 객체가 할당되는 영역입니다. 위에 2가지 전제에서 얘기했다시피, 대부분의 객체가 금방 접근 불가 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라집니다.

Young 영역에 대한 가비지 컬렉션을 `Minor GC`라고 부릅니다.

### Old 영역
Old 영역은 Young 영역에서 `Reachable` 상태를 유지하여 살아남은 객체가 복사되는 영역입니다.

Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생합니다.

Old 영역에 대한 가비지 컬렉션을 `Major GC` 또는 `Full GC`라고 부릅니다.

> 위 그림에서 old 영역이 young 영역보다 크게 할당되는 이유는, 큰 객체들은 young 영역이 아니라, 바로 old 영역으로 할당되며, 수명이 짧은 객체들은 큰 공간을 필요로 하지 않기 때문입니다.

### Eden 영역
![eden.png](images%2Feden.png)
young 영역은 더욱 효율적인 GC를 위해 3가지 영역으로 또 나뉘게 됩니다.(`Eden, survivor0, survivor1`)
- `Eden 영역`: 새로 생성된 객체가 할당되는 영역
- `Survivor 영역`: 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역

객체가 새롭게 생성되면 young 영역 중에서도 Eden 영역에 할당이 됩니다. 그리고 Eden 영역이 꽉 차면 Minor GC가 발생하게 되는데, 사용되지 않는 메모리는 해제되고 Eden 영역에 존재하는 객체는 (사용 중인)Survivor 영역으로 옮겨지게 됩니다.
> (사용 중인) Survivor 영역: Survivor 영역은 총 2개이지만 반드시 1개의 영역에만 데이터가 존재해야하는데, 데이터가 존재하는 Survivor 영역을 뜻하는 듯 합니다.

위의 과정이 반복되다가, Survivor 영역이 가득 차게 되면 Survivor 영역의 살아남은 객체를 다른 Survivor 영역으로 이동시킵니다.(1개의 Survivor 영역은 반드시 빈 상태가 된다.)

이러한 과정을 반복하여 계속해서 살아남은 객체는 Old 영역으로 이동(Promotion)됩니다.

잠깐 그림으로 간단히 살펴보자면,
![sweep.png](images%2Fsweep.png)
Minor GC가 발생한 뒤, Survivor 영역 중 하나로 살아남은 객체를 이동시키면,

아래와 같은 그림이 됩니다.

![age.png](images%2Fage.png)
그림에서 보면 `age`라는 값으로 `1`이 적혀있음을 알 수 있는데, 이는 `살아남은 횟수`를 의미합니다.

위에서 계속해서 살아남은 객체는 Old 영역으로 이동(`Promotion`)한다고 했는데, 이를 age로 판단합니다.
> JVM 중 가장 일반적인 HotSpot JVM의 경우 이 age의 기본 임계값은 31입니다. 객체 헤더에 age를 기록하는 부분이 6 bit로 되어 있기 때문이라고 합니다.

> ✨ 또한, 두 Survivor 영역에 모두 데이터가 존재하거나, 모두 사용량이 0이라면 현재 시스템이 정상적인 상황이 아니라는 반증이 된다고 합니다.(Survivor 영역 중 1개는 반드시 사용되어야한다.)

이 다음 Minor GC는 아래와 같은 과정으로 진행됩니다.
![sweep2.png](images%2Fsweep2.png)

![age2.png](images%2Fage2.png)

이러한 과정을 계속 반복하게 됩니다.

잠깐 다시 짚고 넘어가자면, Young 영역의 Minor GC는 Eden 영역이 꽉찬 경우 발생합니다.

또한, Old 영역의 Major GC는 Old 영역이 꽉찬 경우 발생하게 됩니다.

앞서 설명드렸듯, Old 영역이 더 큽니다. 따라서 GC의 실행속도가 느립니다.(메모리에서 데이터를 찾는게 오래 걸릴 것이기 때문)
> 당연하게도, Young 영역에서의 GC는 공간이 적은 곳에서 발생하는 것이기 때문에 속도가 빠릅니다.

Young 영역의 GC 같은 경우 `0.5 ~ 1초` 사이에 끝이 난다고 합니다. 그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않습니다.

하지만 Old 영역의 Major GC는 Minor GC보다 10배 이상의 시간을 사용한다고 하는데요.

바로 여기서 `Stop-the-World`라는 문제가 발생하게 됩니다.
```markdown
STW (Stop The World)
: GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미합니다.

GC가 작동하는 동안 GC 관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있습니다.
(GC가 작동하는 동안 스레드를 멈추는 이유는, GC 중에는 참조 변경이 발생하면 안되기 때문입니다.)

따라서 이 시간을 최소화 시키는 것이 쟁점입니다.
```

Stop-the-World 도 그렇고, GC의 성능을 위해서 여러 GC 알고리즘들이 있는 것 같습니다.

