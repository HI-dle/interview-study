# CS 기초 지식 보충

---

## 인덱스 



 - 인덱스(Index)란 추가적인 쓰기 작업과 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상 시키기 위한 자료구조이다.
![index.png](image%2Findex.png)



 - 트리 구조나 해시 테이블을 사용하기 때문에 자료구조라고 표현하기도 한다.



### 인덱스 구조
 - 일반적으로 키와 값으로 구성된다. 키는 검색에 사용되는 컬럼이나 컬럼의 조합이며, 값은 해당 레코드를 가리키는 포인터이다. 포인터를 통해 레코드를 직접 읽는 것이다.

 - 인덱스 구현에는 해시테이블, B트리, B+트리 구조를 보통 사용한다.



### 해시 테이블
 - 해시 테이블은 매우 많은 데이터를 고정된 크기의 배열 인덱스로 매핑하여 빠르게 검색할 수 있도록 설계된 자료구조이다. 데이터를 빠르게 찾아 내는 자료구조로 O(1)의 시간 복잡도를 가진다. unordered_map으로 구현한다.

 - unordered_map은 해시 테이블을 구현한 C++ STL 컨테이너 중 하나이다. 해시 함수를 이용해 키 값을 배열 인덱스로 변환하고 이 인덱스에 해당하는 배열의 원소에 값을 저장한다. 즉, 해시 테이블은 배열과 연관된 자료구조이다.

 - 해시 테이블의 동작 원리는 키 값의 해시 값을 계산하고 해시 값을 인덱스로 사용해 데이터를 저장하거나 검색한다.

 - 일반적으로 해시 함수는 키 값을 받아 고정된 길이의 숫자 값인 해시 값을 반환한다. 해시 값은 배열의 인덱스를 구하기 위한 값으로 사용된다. 하지만 해시 테이블에서 서로 다른 키 값이 같은 해시 값을 반환할 경우가 생기고 데이터 저장시 다른 키에 대해 같은 인덱스로 데이터를 저장하게 되면 해시 충돌이 일어난다.



### 해시충돌
 - 해시 충돌을 해결하기 위해서는 체이닝과 개방 주소법이 있다.

 - 체이닝은 해시 충돌이 발생하면 해당 인덱스에 연결 리스트를 생성해 동일한 인덱스에 포함된 다른 데이터와 함께 연결 리스트에 추가하는 방법이며 충돌된 데이터는 리스트에 순차적으로 삽입한다.

 - 개방 주소법은 해시 충돌이 발생하면 다른 빈 인덱스를 탐색해 데이터를 저장하는 방법이다. 아래와 같은 방법이 제시 된다.



    - 선형 탐사 (Linear Probing): 한 칸씩 순차적으로 다음 슬롯 확인
    - 제곱 탐사 (Quadratic Probing): i² 간격으로 탐색
    - 이중 해싱 (Double Hashing): 보조 해시 함수 사용해 점프 간격 계산






 - 실제 해시 테이블은 인덱스에 잘 사용되지 않는데 이유는 해시 테이블 안 데이터는 정렬이 되어있지 않으므로 빠른 시간 안에 찾는 인덱스 구성에 맞지 않다.



### B-트리
![btree.png](image%2Fbtree.png)

 - B-트리는 균형 잡힌 다진 트리 구조로, 대용량 데이터를 정렬된 형태로 저장하고 빠르게 검색, 삽입, 삭제가 가능한 자료구조이다.

 - 각 노드는 여러 개의 키와 자식 노드를 가지며, 루트, 내부 노드, 리프 노드로 구성됩니다. 리프 노드는 일반적으로 데이터 페이지를 가리키며, 모든 리프 노드는 같은 깊이에 존재해 트리의 균형을 유지한다.

 - 검색은 루트 노드부터 시작해 이진 탐색으로 하위 노드를 선택하며 리프 노드까지 내려갑니다. B-트리는 키와 데이터를 노드에 함께 저장하므로 노드 크기가 커지고 디스크 I/O가 많아지는 단점이 있다.

 - B-트리 동작 순서는 다음과 같다.


````
1. 루트 노드에서 시작

2. 현재 노드의 키들을 이진 탐색

3. 탐색 키보다 작고 큰 키 사이의 자식 노드로 이동

4. 리프 노드까지 내려가며 이 과정을 반복

5. 리프 노드에서 데이터 포인터를 따라 실제 페이지 조회
````


 - B-트리의 경우 키 값과 데이터 값이 노드 안에 함께 저장되기 때문에 노드의 크기가 크고 디스크 I/O 작업이 많아지는 문제가 있다. 이러한 단점을 보완한 구조가 B+트리이다. B+트리는 모든 데이터를 리프 노드에만 저장하고, 내부 노드는 키만 포함한다. 또한 리프 노드들은 포인터로 연결돼 있어 범위 검색 성능이 뛰어나다.



 - 디스크 I/O가 많아지는 이유는 B-트리는 키(Key)와 값(Value) 또는 데이터 포인터를 모든 노드에 저장한다. 디스크는 보통 고정 크기 페이지 단위로 읽고 쓰기를 한다. 노드가 커지면 하나의 디스크 페이지에 들어가지 않아 더 많은 페이지로 나뉘고 검색/삽입/삭제 시 더 많은 디스크 접근이 필요하게 된다. 내부 노드에도 값이 있어서 트리의 비교/탐색 과정에서 루트 → 내부 → 리프까지 여러 번 디스크 접근이 발생한다.



### 인덱스 재정렬이 일어난다면?

 - B-트리는 스스로 균형을 유지하는 자료구조이기 때문에 직접 재정렬하거나 인덱스를 손대지 않아도 DBMS가 자동으로 트리 균형과 정렬 유지한다. 노드에 대해 분할하고 중앙 값을 부모로 승격하고 형제 노드를 병합 하거나 재이동 한다.

 - 많은 삽입/삭제가 반복되면 인덱스가 단편화되고 그럴 경우 인덱스 재구성을 수동으로 해주기도 함.



### B+트리

![b+tree.png](image%2Fb%2Btree.png)

 - B+트리는 B-트리의 단점을 개선한 자료구조로, 모든 데이터를 리프 노드에만 저장하고 내부 노드는 키만 저장하는 구조이다. 대용량 데이터의 검색 및 범위 조회 성능을 향상시키기 위해 데이터베이스 인덱스 구조에 자주 사용된다.

   - 루트 노드, 내부 노드, 리프 노드로 구성된다.

   - 내부 노드: 검색을 위한 키만 저장하며, 자식 노드를 가리키는 포인터를 가진다.

   - 리프 노드: 모든 실제 데이터를 저장하고, 옆의 리프 노드와 연결되는 포인터를 가진다(Linked List 구조).

   - 모든 리프 노드는 같은 레벨에 위치하여 트리의 균형을 유지한다.

   

### 동작 순서
````
1. 루트 노드부터 시작

2. 내부 노드에서 키 값을 이진 탐색

3. 키 값에 따라 하위 노드(서브 트리)로 이동

4. 리프 노드까지 반복

5. 리프 노드에서 원하는 키와 데이터 검색
````




 - 모든 실제 데이터는 리프 노드에만 저장된다. 내부 노드는 오직 탐색을 위한 키만 포함하므로 노드 크기가 작아지고 트리 높이가 낮아진다. 리프 노드끼리 연결되어 있어 범위 검색이 빠르다. 디스크 I/O 횟수가 줄어들고 검색 성능이 B-트리에 비해 우수하다.





 - 내부 노드에 데이터가 없고 키만 있으므로 더 많은 키를 한 페이지에 저장할 수 있다. 리프 노드가 연결되어 있어 연속된 데이터 조회 시 추가적인 탐색 없이 순차 접근이 가능하다.





 - B+트리 역시 삽입과 삭제 과정에서 자동으로 트리 균형을 유지한다. 노드가 가득 차면 분할, 부족하면 병합 또는 재분배 한다. 데이터의 빈번한 변경으로 인해 인덱스가 단편화(fragmentation) 될 수 있으며, 이 경우 REBUILD INDEX 와 같은 명령어로 인덱스를 재구성할 수 있다.



 - REBUILD INDEX는 데이터베이스에서 인덱스를 다시 만드는 작업이다. 인덱스가 시간이 지나면서 데이터 변경으로 인해 단편화 되거나 비효율적으로 변할 수 있는데 이때 인덱스를 재구성하여 단편화를 해소하고 성능을 최적화 한다. 단편화는 쓰기 작업에 대해 빈 공간이 조각 조각 생기는 것을 말한다.

 - 인덱스를 새로 생성하면서 노드들을 최적의 크기와 구조로 재배치, 비어있는 공간을 정리해 디스크 공간 효율 향상한다.

 - 인덱스가 자주 수정되는 테이블에서 성능이 떨어질 때, 인덱스 단편화가 심할 때, 대량의 데이터 삭제 후에 사용된다.



### 인덱스 장점
 - 빠른 검색 속도, 중복 데이터 제거, 데이터 정렬



### 인덱스 단점
 - 생성 시간의 소요, 데이터 공간 차지, 추가적인 작업



### 인덱스 사용시 주의점
 - 인덱스는 무분별하게 사용하거나 구조를 이해하지 못한 채 설정하면 오히려 성능 저하를 일으킬 수 있다.


~~~
1. 과도한 인덱스 설정

인덱스는 SELECT 성능을 향상시키지만 INSERT, UPDATE, DELETE와 같은 쓰기 작업에는 부담이 된다. 데이터가 변경될 때마다 관련된 인덱스도 함께 갱신되어야 하기 때문에 인덱스가 많을수록 쓰기 성능은 느려진다. 따라서 자주 조회되는 컬럼이나 필터링 조건에 사용되는 컬럼 중심으로 전략적으로 필요한 인덱스만 설정하는 것이 중요하다.



2. 복합 인덱스는 순서를 지켜야 효과적이다.

복합 인덱스는 여러 컬럼을 묶어서 만든 인덱스이다. 예를 들어 (a, b)라는 인덱스가 있다면 이 인덱스는 a 단독 또는 a와 b를 함께 사용할 때만 효과가 있다. 반면, WHERE b = ?만 사용하는 쿼리는 이 인덱스를 타지 못하고 전체 테이블을 탐색할 수 있다. 이를 선행 컬럼 조건이라고 하며 복합 인덱스를 사용할 때 반드시 고려해야 할 요소이다.



3. LIKE 검색은 인덱스를 무시할 수 있다.

LIKE 조건을 사용할 때 와일드카드(%)가 앞에 오면 인덱스를 사용할 수 없다. 예를 들어 WHERE name LIKE '%철수'와 같은 쿼리는 전체 테이블을 스캔하게 된다. 하지만 WHERE name LIKE '김%'처럼 와일드카드가 뒤에 오는 경우에는 인덱스를 사용할 수 있다. 와일드카드를 앞에 오지 않게끔 구성해야 한다.



4. 함수나 연산이 들어간 조건절은 피해야 한다.

WHERE 절에서 컬럼에 함수나 연산이 들어가면 인덱스를 사용할 수 없다. 예를 들어 WHERE DATE(created_at) = '2025-05-01'처럼 컬럼에 DATE() 함수를 사용하면 인덱스가 무시된다. 이 경우에는 WHERE created_at >= '2025-05-01' AND created_at < '2025-05-02'처럼 범위 조건을 사용하는 것이 인덱스를 활용할 수 있는 방법이다.



이외로 중복도가 높은 컬럼은 인덱스 효율이 낮다, 데이터 쓰기 작업이 잦다면 단편화 발생 부분을 주의해야 한다.
~~~


 - 인덱스를 많이 걸면 쓰기 성능 저하, 디스크 공간 사용 증가가 있다.

 - 인덱스를 사용하지 않는다면 테이블을 전체 탐색하게 되고 결과적으로 응답 속도가 느려지고, 서버 CPU, I/O 부하 증가된다.







## 동기화 (Synchronization)
 - 동기화는 멀티스레드 환경에서 여러 개의 스레드가 공유 자원에 접근하는 것을 조율하는 기술을 말한다. 동시에 여러 스레드가 동일한 자원에 접근할 때, 이를 조정하여 문제들을 해결하고 스레드들이 순서대로 작업을 수행하도록 한다.

 - 동기화를 통해 경쟁 조건(Race Condition)을 방지하고 데이터 일관성을 보장할 수 있다.



## 교착상태 (Deadlock)
 - 교착상태는 멀티스레드 시스템에서 두 개 이상의 스레드가 서로 상대방이 점유한 자원을 기다리며 무한히 대기하는 상태를 말한다.

 - 교착상태가 발생하면 시스템이 멈추게 되며, 해결하기 어려운 상태가 된다.

 - 교착상태를 방지하기 위해선 상호 배제, 점유와 대기, 비선점, 순환 대기라는 4가지 조건 중 적어도 하나를 깨뜨려야 한다.



## 뮤텍스 (Mutex)
 - 뮤텍스는 동기화를 위한 기법 중 하나로, 공유 자원을 여러 스레드가 동시에 접근하는 것을 막는다.

 - 뮤텍스를 소유한 스레드만이 임계 영역(Critical Section)에 접근할 수 있으며, 다른 스레드들은 뮤텍스를 획득하기 위해 대기한다.

 - 하나의 뮤텍스는 오직 하나의 스레드만이 소유할 수 있으며, 뮤텍스를 사용하는 스레드는 작업을 완료한 후 뮤텍스를 해제해야 한다.



## 세마포어 (Semaphore)
 - 세마포어는 뮤텍스와 유사한 동기화 기법으로, 공유 자원에 접근하는 스레드의 수를 제어할 수 있다.

 - 세마포어는 초기 값을 설정하고, 접근하려는 스레드는 세마포어 값을 확인하여 접근 여부를 결정한다.

 - 뮤텍스는 스레드가 작업을 마치면 직접 해제하지만, 세마포어는 특정 조건에 따라 자동으로 값을 변경하여 다른 스레드들이 접근할 수 있도록 한다.



## 인증(Authentication)과 인가(Authorization)의 차이점
 - 인증(Authentication)과 인가(Authorization)는 웹 시스템에서 보안과 관련된 개념으로, 사용자의 접근을 제어하는 데 사용된다. 두 개념은 유사하게 보일 수 있지만, 목적과 처리 방식에 차이가 있다.
 - 인증은 사용자의 신원을 확인하는 과정이다. 인증은 보통 사용자의 ID와 비밀번호를 확인하여, 해당 사용자가 누구인지 확인하는 과정을 의미한다. 인증 과정을 거친 후에는, 시스템에서 사용자의 신원을 인정하고, 해당 사용자가 시스템에 접근할 수 있도록 한다.
 - 반면, 인가는 인증된 사용자가 시스템 내의 리소스에 접근할 때, 어떤 작업을 수행할 수 있는지를 결정하는 과정이다. 권한 부여는 보통 사용자의 역할(Role)이나 그룹(Group) 등의 정보를 확인하여, 해당 사용자가 수행할 수 있는 작업을 결정한다. 예를 들어, 관리자 권한을 가진 사용자는 시스템의 모든 리소스에 접근할 수 있지만, 일반 사용자는 제한된 리소스에만 접근할 수 있다.
 - 요약하면, 인증은 사용자의 신원을 확인하고, 인가는 인증된 사용자가 수행할 수 있는 작업을 결정하는 과정이다. 인증과 권한 부여는 웹 시스템에서 보안을 유지하고, 안전한 접근을 보장하는 데 중요한 역할을 한다.