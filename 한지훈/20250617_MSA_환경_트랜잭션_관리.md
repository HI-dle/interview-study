# MSA 환경 트랜잭션 관리

---

### 분산 트랜잭션의 복잡성

- **모놀리식 애플리케이션의 경우**
    - 하나의 데이터베이스만 접근하므로, Spring 등 프레임워크가 제공하는 선언적 트랜잭션(@Transactional 등)을 사용해 간단히 트랜잭션을 관리할 수 있다.
    - 모든 데이터가 한 군데에 있으니 커밋/롤백 로직이 단순.
- **마이크로서비스 환경의 경우**
    - 각각의 서비스가 별도의 DB나 메시지 브로커 등을 사용하므로, 하나의 비즈니스 로직에도 여러 서비스가 연계된다.
    - 전통적인 분산 트랜잭션(XA 프로토콜, 2PC 등)을 적용하려면 여러 제약이 따른다.
        - 많은 NoSQL DB나 Kafka, RabbitMQ 등 최신 기술은 XA 같은 2PC 트랜잭션을 지원하지 않는다.

### 2PC/XA 프로토콜 한계

- **XA 프로토콜(2PC)을 이용한 전통적 분산 트랜잭션**
    - 이론적으로는 여러 자원을 동시에 커밋/롤백 가능하나, 최신 NoSQL·메시지 브로커가 지원하지 않는 경우가 많으며, 이종(heterogeneous) 환경에서 적용이 어렵다.
    - 참여 노드가 모두 항상 가용해야 하므로, 시스템 전체 가용성을 떨어뜨리는 요인이 된다.

 - 마이크로서비스 환경에서는 분산 트랜잭션을 쉽게 처리하기가 어려우며 Saga 패턴 같은 대안적 접근이 널리 쓰이게 되었다.

> **2PC/XA(eXtended Architecture) 프로토콜**
> 
> Spring Boot 대표적으로 2-Phase-Commit(2PC) 또는 SAGA 패턴을 사용하여 분산 트랜잭션을 관리한다.
> 여러 서비스에서 트랜잭션을 관리하는 데 사용할 수 있는 Atomikos 및 Bitronix 트랜잭션 관리자를 통해 XA 트랜잭션을 지원한다.
> 
> XA는 분산 컴퓨팅 환경에서 여러 리소스 (예: 데이터베이스, 메시징 시스템) 간의 트랜잭션을 조율하기 위한 표준 인터페이스이다. 이 인터페이스는 2-Phase-Commit 프로토콜을 사용하여 트랜잭션을 완료한다.

- 2PC은 두 단계로 구분되어 작동된다.

 - Prepare Phase (준비 단계): 트랜잭션 매니저 (TM)는 모든 리소스 매니저 (RM)에게 트랜잭션 커밋 준비를 알린다. RM들은 이 요청을 받고 필요한 모든 작업을 준비하며 준비가 완료되면 응답한다.

 - Commit/Rollback Phase (커밋/롤백 단계): 모든 RM이 준비되면 TM은 트랜잭션을 커밋한다. 만약 어떤 RM이 준비되지 않았다면, TM은 트랜잭션을 롤백한다.

![2pc.png](image%2F2pc.png)

 - Prepare Phase (준비 단계)
   유저가 Coordinator를 통해 금액 이체를 요청
   Coordinator(TransferService)는 계좌 A (AccountAService)와 계좌 B (AccountBService)에게 prepare 상태인지 확인을 요청
   각 계좌 서비스는 자신의 상태를 확인하여 prepare 상태이면 준비 완료 응답을 반환하고, 그렇지 않으면 준비 실패 응답을 반환

 - Commit/Rollback Phase (커밋/롤백 단계)
   Coordinator는 모든 계좌 서비스로부터 응답을 받는다.
   만약 모든 서비스가 prepared 응답을 반환하면, Coordinator는 각 계좌 서비스에 커밋을 요청
 - commit 호출에 따라 계좌 A에서는 출금이 이루어지고, 계좌 B에서는 입금이 이루어진다.
  그러나 하나 이상의 서비스에서 prepared 실패 응답을 받으면, Coordinator는 롤백을 요청
 - rollback 호출에 따라 이전 상태로 복구된다.


> 원자성 보장: 2PC의 핵심은 여러 데이터베이스나 서비스에 걸쳐 있는 트랜잭션도 하나의 트랜잭션처럼 다룰 수 있게 해준다는 것
즉, 모든 작업이 성공적으로 수행되거나 아무 작업도 수행되지 않은 것처럼 보장된다.
> 
> 코디네이터의 중요성: 코디네이터는 분산 트랜잭션을 관리하고 조율하는 중요한 역할을 한다.
모든 작업의 상태를 모니터링하고, 최종 커밋 또는 롤백 결정을 내린다.


### 2PC를 사용하였을 경우의 문제점

 - 트랜잭션의 책임이 Coordinator Node에 있으며 이 부분이 단일 실패지점(SPOF)가 될 수 있다.
 - 전체 트랜잭션이 완료될 때까지 서비스에서 사용하는 리소스가 잠겨 있어 서비스가 완료될 때까지 대기해야 한다. 때문에 지연 시간이 늘어나고 리소스가 차단되어 확장이 어려워질 수 있다.
 - NoSQL은 2PC-분산 트랜잭션을 지원하지 않는다.

## SAGA 패턴
 - SAGA 패턴은 MSA환경에서 일관성을 지키기 여렵다는 것을 기반으로, 약간의 일관성을 포기하고 Eventual Consistency(최종 일관성)을 보장하여 효율성을 높이기 위한 패턴이다.

 - 2PC에서는 트랜잭션을 하나의 트랜잭션으로 묶어서 처리를 하지만, SAGA 패턴은 긴 트랜잭션을 여러 개의 짧은 로컬 트랜잭션으로 분리하는 접근 방식이다.
 - 각 트랜잭션은 다른 트랜잭션의 완료를 기다리지 않고 독립적으로 실행된다. 따라서 트랜잭션의 원자성을 지켜줄 방법이 필요하다. 만약 중간에 문제가 발생하면, 보상(Compenstation) 트랜잭션이 실행되어 이전 트랜잭션을 롤백하는 것과 같은 효과를 가져옵니다.



### 왜 Saga가 해결책인가?

- **분산 트랜잭션의 대안**
    - 전통적 2PC가 적용 곤란한 마이크로서비스 환경에서, 각 서비스가 **로컬 트랜잭션**만 책임지고, 단계별로 성공/실패 시 이벤트 혹은 지휘(Orchestrator)를 통해 전체 흐름을 제어하는 방식.
- **로컬 트랜잭션 + 보상 트랜잭션**
    - 한 단계가 커밋된 뒤 다음 단계로 넘어가는 시점에서 장애가 발생하면, 이미 커밋된 작업을 되돌리는(보상) 로직으로 정합성을 맞춤.

 - 사가 패턴은 이벤트기반으로 작동한다.

## 종류

 - SAGA 패턴을 구현하는 방법은 두가지가 있다.

   - Choreography SAGA(코레오크레피 사가)
   - Orchestration SAGA(오케스트레이션 사가)

### Choreography

 - Choreography 방식은 각 서비스끼리 이벤트를 주고 받는 방식이다.
 - 각 서비스가 다른 서비스의 로컬 트랜잭션을 이벤트 트리거하는 방식으로 이루어 진다.

 - 이 방식은 중앙집중된 지점이 없이 모든 서비스가 메시지 브로커(RabbitMQ, Kafka)를 통해 이벤트를 Pub/Sub 하는 구조다.

 - 중앙 집중형 관리방식이 아니기 때문에 SPOF(단일 실패지점)이 없다.
 - 새로운 서비스 추가가 필요할 때 서비스간 연결을 잘 확인 해야한다.
 - 서비스끼리 이벤트를 주고 받기 때문에 큰 시스템의 경우 구조의 파악이 어려워 질 가능성이 있다.
 - 트랜잭션을 시뮬레이션하기 위해 모든 서비스를 실행해야하기 때문에 통합테스트와 디버깅이 어려운 점이 있다.

![Choreography.png](image%2FChoreography.png)


### 장점

- **SPOF(단일 장애점) 부재**
    - 중앙 Orchestrator가 없으므로 한 지점 장애로 전체가 멈추지 않는다.
- **확장성**
    - 이벤트 기반으로 서비스가 늘어나도, 구독만 추가하면 새 기능을 붙이기 relatively 쉽다.

### 단점

- **이벤트 플로우 분산**
    - 전체 비즈니스 로직이 여러 서비스 이벤트로 쪼개져 있어, 디버깅/관리 난이도가 상승한다.
- **이벤트 순서, 중복, 사이클**
    - 순서 보장, 같은 이벤트를 여러 번 처리하지 않도록 하는 로직, 순환 참조 등을 신중히 설계해야 한다.



### Orchestration

![Orchestration.png](image%2FOrchestration.png)

 - 오케스트레이션 사가는 중앙 집중형으로 실행 흐름을 관리하게 된다.
 - Ochestrator는 요청을 실행, 각 서비스의 상태를 확인하고, 실패에 대한 보상 트랜잭션을 실행한다.

### 장점

1. **간단해지는 의존관계 (Simpler Dependencies)**
    - 모든 흐름을 Orchestrator가 관리 → 순환 의존이 없다.
2. **느슨한 결합 (Loose Coupling)**
    - 각 서비스는 Orchestrator가 주는 Command에만 반응하면 되므로, 서비스 간 직접적 호출이 줄어든다.
3. **관심사의 분리 강화**
    - 전체 비즈니스 로직(흐름 제어)은 Orchestrator에 모이고, 각 서비스는 로컬 트랜잭션에 집중된다.

### 단점

- **비즈니스 로직의 중앙 집중화**
    - Orchestrator에 과도한 로직이 쏠리면 지나치게 스마트한 중앙 시스템이 되고, 각 서비스는 단순해질 위험이 있다.
    - 단일 장애점(SPoF)이 될 수 있으므로 HA 구성을 고려해야 한다.
- **성능 이슈**
    - 모든 요청이 Orchestrator를 경유하므로 레이턴시가 추가되고, Throughput 한계가 Orchestrator 성능에 좌우된다.




---

- 마이크로서비스에서 트랜잭션을 다루려면 **Saga 패턴**이 사실상 필수이며, 오케스트레이션 vs 코레오그래피는 **업무·인프라 상황**에 맞춰 고르거나 혼합 사용 가능하다.
- Outbox 패턴, 보상 트랜잭션 설계, 메시지 브로커 연동 등 여러 요소를 종합적으로 고려해야 한다.
