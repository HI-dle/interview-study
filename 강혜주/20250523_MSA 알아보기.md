## 시작하며
> 최근 프로젝트에서 MSA 를 도입했다.
> 특징과 장단점을 모놀리식 아키텍쳐와 비교하며 작성해본다

## Monolithic Architecture
![](https://velog.velcdn.com/images/hyezuu/post/b05084d5-8f58-4a10-b3f3-57ee22238c0e/image.png)

>  하나의 큰 코드베이스로 구성된 애플리케이션을 말하며, 모든 기능이 하나의 애플리케이션 내에 포함되어있는 구조를 말한다.

### 모놀리식 아키텍쳐의 장단점
#### 장점
- 모든 서비스가 하나의 애플리케이션 내에 존재하므로, 서비스간 통신 오버헤드가 적어 속도가 빠를 수 있다.
- 초기 개발 및 배포가 단순하다.
- 모든 기능이 하나의 DB에 연결되어있으므로 트랜잭션 처리가 편리하다.
- 테스트 및 디버깅이 쉽다.

#### 단점
- 부분 장애가 전체 서비스의 장애로 확대될 수 있다.
	- DB 커넥션풀, 서비스풀, 캐시(레디스), 파일시스템 I/O 등 모든 자원을 함께 공유하므로, 공유자원의 병목 또는 고갈 발생시 전체 서비스의 장애로 이어진다.
	- 특정 로직 내에서 예외 또는 무한루프등으로 어플리케이션 내에 장애가 발생하면 전체 서비스의 장애로 확대될 수 있다.
- 규모가 커질수록 관리가 어렵다
	- 기능이 많아지게되면 모듈 간 의존성이 꼬이거나, 유지보수가 힘들어진다.
	- 새로운 팀원이 합류하게 되었을 때 전체 구조를 파악하기 힘들 수 있다.
- 부분 수정도 전체 빌드 및 배포가 필요하다.
	- 예를 들면 결제 기능을 확장하는 경우, 전체 애플리케이션을 재빌드하고 배포해야한다.
	- 개별 기능 단위 배포가 불가능하다.
- 확장성이 떨어진다.
	- 하나의 인스턴스 내에서 모든 기능을 다루므로, 특정 서비스만 수평적으로 확장하는 것이 불가능하다.
	- 일부 기능에 부하가 심해도 전체 서비스 리소스를 함꼐 늘려야 한다.
- 기술 혼합이 어렵다.
	- 하나의 코드베이스로 이루어져 있으므로 다양한 언어나 프레임워크를 섞기 힘들다.
	- 새로운 기술 도입이 제한된다.

#### 적합한 경우
- 스타트업, 초기 개발단계
- 작은 팀, 짧은 기간, 빠른 mvp 개발이 필요할 떄
- 비즈니스 로직이 단순하거나 적은 기능만 필요한 경우

## Microservice Architecture
![](https://velog.velcdn.com/images/hyezuu/post/9032ed95-19bc-47da-aa5f-0499b075f343/image.png)
>  여러개의 독립적인 서비스로 구성된 시스템을 의미한다. 각 서비스는 독립적으로 배포되고 운영될 수 있다.
>  여기서 서비스란 기능의 독립적인 단위를 말한다. 서비스 간 통신은 주로 네트워크, 메시지 큐 등을 통해 이루어진다.

### 마이크로 서비스 아키텍쳐의 장단점
#### 장점
- 기능별 독립 배포가 가능하다.
	-  특정 기능만 수정하고 배포할 수 있다. 장애 시에도 전체 재배포 없이 해당 서비스만 롤백 가능하다.
	-  예시 ) 변경이 발생한 모듈만 독립적으로 배포가능
	   ![](https://velog.velcdn.com/images/hyezuu/post/4427dfdd-f3f3-44a3-8570-a21d35e1d83d/image.png)

- 장애 격리가 가능해진다.
	- 하나의 서비스 등에 장애가 발생해도 다른 서비스는 정상 동작할 수 있다.
	- Circuit Breaker(Resiliance4j)를 통해 fall back 메서드를 구현하면 우아한 장애처리가 가능해진다.
- 확장성
	- 부하가 많은 서비스만 개별적으로 scale-out 가능하다
	- 모든 서비스가 별도의 인스턴스로 분리되어 있으므로 오토스케일링 가능
- 서비스마다 팀의 상황에 맞는 기술 스택을 선택할 수 있다
	- 특정 기술에 더이상 종속적이지 않을 수 있다.
- 조직 독립성
	- 팀 단위로 개발/운영/배포가 가능해진다. 기능별 책임분리에 적합하다

#### 단점
- 인프라 구성이 복잡하다.
	- 서비스가 많아질수록 배포, 모니터링, 로깅, 보안 설정도 함께 늘어나게 된다.
- 네트워크 비용/지연이 발생한다
	- 서비스 간 통신이 네트워크를 통해 이루어지기 떄문에 레이턴시가 증가한다
- 데이터의 일관성 보장이 어렵다.
	- 각 서비스가 별도의 DB를 가지므로 ACID를 지키기 힘들다 (consistency)
	- 분산 트랜잭션, 최종적 일관성을 고려해야한다.
- 테스트 복잡도가 증가한다.
	- 통합테스트가 어려워진다 (mocking 필요)
- 운영 난이도가 증가한다.
	- 장애 분석이 어렵고, 분산추적이 필요해진다. (Zipkin 등)
	- 특정 서비스에 병목이 발생했을 때 추적이 쉽지않다.

## MSA 도입 이유

- 도메인 중심 설계와 기능단위 개발을 고려했을 때, 각 바운디드 컨텍스트를 마이크로 서비스의 경계로 설정할 수 있다.
- 각 기능이 독립적으로 분리되어 장애 격리 및 독립 배포가 가능해진다.
- 팀원 별 역할 분담을 명확히 하여 생산성을 높일 수 있다.
- 지속 가능한 개발 및 유지보수성 고려

###  Spring Cloud 주요 모듈
![](https://velog.velcdn.com/images/hyezuu/post/a5c63767-80ef-4ee0-822f-a571199b4f08/image.png)

####  서비스 등록 및 디스커버리
- Eureka
	- 넷플릭스가 개발한 서비스 디스커버리 서버로, 마이크로서비스 아키텍처에서 각 서비스의 위치를 동적으로 관리
	- **주요 특징**:
		- 서비스 레지스트리: 모든 서비스 인스턴스의 위치를 저장하는 중앙 저장소
		- 헬스 체크(Health check): 서비스 인스턴스의 상태를 주기적으로 확인하여 가용성을 보장

####  로드 밸런싱
- Ribbon
	- 넷플릭스가 개발한 클라이언트 사이드 로드 밸런서로, 서비스 인스턴스 간의 부하를 분산
	- **주요 특징**:
		- 서버 리스트 제공자: Eureka로부터 서비스 인스턴스 리스트를 제공받아 로드 밸런싱에 사용
		- 로드밸런싱 알고리즘: 라운드 로빈, 가중치 기반 등 다양한 로드 밸런싱 알고리즘 지원
		- Failover: 요청 실패 시 다른 인스턴스로 자동 전환
		- Feign-Client 사용시 내부적으로 로드밸런서가 동작한다.

#### 서킷 브레이커
- Resilience4j
	- Resilience4j는 자바 기반의 경량 서킷 브레이커 라이브러리로, 넷플릭스 Hystrix의 대안으로 개발
	- **주요 특징**:
		- **서킷 브레이커**: 호출 실패를 감지하고 서킷을 열어 추가적인 호출을 차단하여 시스템의 부하를 줄임
		- **Fallback**: 호출 실패 시 대체 로직을 실행하여 시스템의 안정성을 유지
		- **타임아웃 설정**: 호출의 응답 시간을 설정하여 느린 서비스 호출에 대응할 수 있음
		- **재시도**: 재시도 기능을 지원하여 일시적인 네트워크 문제 등에 대응할 수 있음
#### API 게이트웨이
- Cloud Gateway
	- 스프링 클라우드에서 제공하는 API 게이트웨이로, 마이크로서비스 아키텍처에서 필수적인 역할을한다. 클라이언트의 요청을 받아 라우팅하는 진입점 역할을 수행한다.
	- **주요 특징**:
		- **루팅 및 필터링**: 요청을 받아 특정 서비스로 라우팅하고 필요한 인증 및 권한 부여를 수행
		- **보안**: 외부 요청으로부터 애플리케이션을 보호하고, 보안 정책을 적용함
		- **효율성**: 마이크로서비스 아키텍처에서 필요한 요청 처리 및 분산 환경의 관리를 효율적으로 수행

#### 구성 관리
- Spring Cloud Config
	- 분산된 환경에서 중앙 집중식 설정 관리를 제공
	- **주요 특징**:
		- Config 서버: 중앙에서 설정 파일을 관리하고 각 서비스에 제공
		- Config 클라이언트: Config 서버에서 설정을 받아서 사용하는 서비스
		- 설정갱신: 설정 변경 시 서비스 재시작 없이 실시간으로 반영할 수 있다


## 마무리
> 간단한 시스템에는 MSA가 과한 선택일 수 있다.
그러나 도메인이 복잡하고, 팀 규모가 커지며, 장애 대응과 독립 배포가 중요한 상황이라면 MSA는 강력한 선택지다.
물론 운영 복잡성과 데이터 일관성 관리라는 대가는 분명 존재한다.
그래서 중요한 건, 기술보다 문제 해결에 집중하는 설계 철학이다.
MSA 는 소프트웨어 개발 기법 중 하나일 뿐이니 프로젝트 규모에 맞는 설계를 선택하도록 하자!


#### 출처
>[# Monolith vs Microservices vs Modular Monoliths: What's the Right Choice](https://blog.bytebytego.com/p/monolith-vs-microservices-vs-modular)<br>
>[# 모놀리식 아키텍처와 MSA의 이해 및 구현](https://f-lab.kr/insight/understanding-and-implementing-monolithic-architecture-and-msa-20240815) <br>
>[# [간단정리] MSA란?(등장배경, 특징, 장단점)](https://hahahoho5915.tistory.com/71) <br>
>[# Do Not Use MSA - 마이크로서비스 아키텍처가 꼭 필요한가요?](https://www.samsungsds.com/kr/insights/msa.html#:~:text=%EC%84%9C%EB%B9%84%EC%8A%A4%20%EB%8B%A8%EC%9C%84%EA%B0%80%20%EC%86%8C%ED%98%95%ED%99%94%EB%90%98%EB%A9%B4%EC%84%9C%20%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EC%99%80%20%EC%97%85%EA%B7%B8%EB%A0%88%EC%9D%B4%EB%93%9C%EA%B0%80%20%EC%83%81%EB%8C%80%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EC%9A%A9%EC%9D%B4%ED%95%B4%EC%A1%8C%EC%9C%BC%EB%A9%B0%20%EC%9D%B4%EB%8A%94%20%EB%A6%B4%EB%A6%AC%EC%A6%88%20%EC%A3%BC%EA%B8%B0%EB%A5%BC%20%EB%8B%A8%EC%B6%95%ED%95%98%EB%8A%94%EB%8D%B0%20%ED%81%B0%20%EC%9D%B4%EC%A0%90%EC%9D%B4%20%EB%90%98%EC%97%88%EC%8A%B5%EB%8B%88%EB%8B%A4.&text=%EC%9D%B4%EB%A6%84%20%EA%B7%B8%EB%8C%80%EB%A1%9C%20%EA%B0%9C%EB%B0%9C(Development)%EA%B3%BC%20%EC%9A%B4%EC%98%81(Operations)%EC%9D%84%20%EB%82%98%EB%88%84%EC%A7%80%20%EC%95%8A%EA%B3%A0%2C%20'%EA%B0%9C%EB%B0%9C,IT%20%ED%99%98%EA%B2%BD%20%EB%98%90%EB%8A%94%20%EB%AC%B8%ED%99%94%EA%B0%80%20%EB%93%B1%EC%9E%A5%ED%95%98%EA%B2%8C%20%EB%90%9C%20%EB%B0%B0%EA%B2%BD%EC%9E%85%EB%8B%88%EB%8B%A4.)



